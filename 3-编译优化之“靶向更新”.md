<!--
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", null, [
      _createElementVNode("h1", null, "title", -1),
      _createElementVNode(
        "p",
        null,
        _toDisplayString($setup.msg),
        1
        /* TEXT */
      ),
      _createElementVNode(
        "button",
        { onClick: $setup.handleChange },
        "change msg"
      ),
    ])
  );
}
-->

整个流程主要分为两个大阶段：编译时和运行时。
编译时阶段找出动态节点，使用 patchFlag 属性将其标记为动态节点。 PatchFlags.CLASS、PatchFlags.TEXT
和 PatchFlags 中的枚举进行&"按位与"运算就可以知道当前节点是否是动态文本节点、动态 class 的节点。
patchFlag |= PatchFlags.CLASS: 当前节点包含动态 class

运行时阶段分为两块：执行 render 函数阶段和更新视图阶段。
执行 render 函数阶段会找出所有被标记的动态节点，将其塞到 block 节点的 dynamicChildren 属性数组中。

执行顺序是内层先执行，外层再执行:openBlock() => createElementVNode(h1) => createElementVNode(p) => createElementVNode(button) => createElementBlock(div)

<!--
openBlock 主要逻辑：
let currentBlock;
function openBlock() {
  currentBlock = [];
} -->

<!--
createElementVNode 主要逻辑：
export { createBaseVNode as createElementVNode };
function createBaseVNode() {
  const vnode = {
    // ...省略
  };
  if (vnode.patchFlag > 0) {
    currentBlock.push(vnode);
  }
  return vnode;
} -->

<!--
createElementBlock 主要逻辑：
function createElementBlock() {
  return setupBlock(
    createBaseVNode()
    // ...省略
  );
}
function setupBlock(vnode) {
  vnode.dynamicChildren = currentBlock;
  return vnode;
}
-->

更新视图阶段会从 block 节点的 dynamicChildren 属性数组中拿到所有的动态节点，然后遍历这个数组将里面的动态节点进行靶向更新。（前后两个虚拟 dom 对比，patchFlag & PatchFlags.TEXT）
dynamicChildren:代表当前节点的子节点的动态节点数组

<!--
function setElementText(el, text) {
  el.textContent = text;
}、
if (patchFlag & PatchFlags.TEXT) {
      if (n1.children !== n2.children) {
        hostSetElementText(el, n2.children);
      }
    }
-->
